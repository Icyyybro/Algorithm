# 错误总结

## 目录

- [1. 语法错误](#1-语法错误)
  - [1.1 double在printf时出错](#11-double在printf时出错)
- [2. 最短路径问题](#2-最短路径问题)
  - [2.1 数组越界](#21-数组越界)
  - [2.2 最短路径矩阵求和问题](#22-最短路径矩阵求和问题)
- [3.差分问题](#3差分问题)
  - [3.1 需要从n到1遍历](#31-需要从n到1遍历)
- [4.并查集](#4并查集)
  - [4.1 find函数有关](#41-find函数有关)

# 1. 语法错误

## 1.1 double在printf时出错

这个问题难点在于编译器并不会报错，只会WA。

如果你要printf的值为double类型，那必须printf("%lf")，而不是%f。

题目中千万不要使用long double。

题目：[P2047 \[NOI2007\] 社交网络](<../练习题：/洛谷/搜索与图论/3. 最短路径/P2047 \[NOI2007] 社交网络/P2047 \[NOI2007] 社交网络.md> "P2047 \[NOI2007] 社交网络")

# 2. 最短路径问题

## 2.1 数组越界

在写无向图的最短路径问题时，由于题目说明边数m<1e9，所以我也想当然的将邻接表的大小开成m，但是由于这是无向图，它给你的一条边(a,b)，你需要存入\<a,b>和\<b,a>，所以至少要开2m大小的邻接表。

题目：[P1462 通往奥格瑞玛的道路](<../练习题：/洛谷/搜索与图论/3. 最短路径/P1462 通往奥格瑞玛的道路/P1462 通往奥格瑞玛的道路.md> "P1462 通往奥格瑞玛的道路")

## 2.2 最短路径矩阵求和问题

在通过floyd产生的最短路径矩阵求解每两个点之间最短路径之和的问题时，不能将矩阵中所有元素相加，而是加上上三角元素或者下三角元素。因为矩阵元素\[i]\[j]表示从i到j的最短路径，遍历整个矩阵，会既加上元素\[i]\[j]也会加上\[j]\[i]，导致重复。

题目：[P6464 \[传智杯 #2 决赛\] 传送门](<P6464 \[传智杯 > "P6464 \[传智杯 #2 决赛] 传送门")[https://www.wolai.com/cP7JphRZ1D12JwX8UfPg9b](https://www.wolai.com/cP7JphRZ1D12JwX8UfPg9b "https://www.wolai.com/cP7JphRZ1D12JwX8UfPg9b")

# 3.差分问题

## 3.1 需要从n到1遍历

题目：

# 4.并查集

## 4.1 find函数有关

注意是if(x≠p\[x])而不是while

```c++
int find_DSU(int p[], int n, int x)
{
  if (x != p[x])
    p[x] = find_DSU(p, n, x);
  else
    return p[x];
}
```
