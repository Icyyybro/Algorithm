# P1083 \[NOIP2012 提高组] 借教室

# \[NOIP2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。

## 输入格式

第一行包含两个正整数 $n,m$，表示天数和订单的数量。

第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $r_i$，表示第 $i$ 天可用于租借的教室数量。

接下来有 $m$ 行，每行包含三个正整数 $d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。

每行相邻的两个数之间均用一个空格隔开。天数与订单均用从 $1$ 开始的整数编号。

## 输出格式

如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。否则（订单无法完全满足）

输出两行，第一行输出一个负整数 $-1$，第二行输出需要修改订单的申请人编号。

## 样例 #1

### 样例输入 #1

```c++
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4
```

### 样例输出 #1

```c++
-1 
2
```

## 提示

【输入输出样例说明】

第 \$1 \$份订单满足后，\$4 \$天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 \$2 \$天到第 $4$ 天每天提供\$ 3 \$个教室，而第 $3$ 天剩余的教室数为\$ 2\$，因此无法满足。分配停止，通知第$2$ 个申请人修改订单。

【数据范围】

对于10%的数据，有$1≤ n,m≤ 10$；

对于30%的数据，有$1≤ n,m≤1000$；

对于 70%的数据，有$1 ≤ n,m ≤ 10^5$；

对于 100%的数据，有$1 ≤ n,m ≤ 10^6,0 ≤ r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n$。

NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

# 题解

这道题需要用差分计算区间\[s\[i], t\[i]]减去同一个数，同时要判断在哪一个订单出现问题，这里可以用二分来解决，因为这个问题是单调的（随着订单变多，剩余的教室变少）。我们在题中二分订单数量，judge函数计算教室数量能否满足订单1→mid的需求，这就需要judge函数初始化一个差分数组diff来记录每天借教室数量（注意不要在剩余教室数组中直接减），最后前缀和diff得到每天借教室的数量。综合代码如下：

```c++
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;


#define max_num 1010000
#define INFINITY 0x3f   
typedef pair<long long, long long> PII;


int n, m;
int a[max_num];
int d[max_num];
int s[max_num];
int t[max_num];
long long diff[max_num];


bool judge(int x)
{
  memset(diff, 0, sizeof diff);
  for (int i = 1; i <= x; i++)
  {
    diff[s[i]] += d[i];
    diff[t[i] + 1] -= d[i];
  }
  for (int i = 1; i <= n; i++)
  {
    diff[i] += diff[i - 1];
    if (diff[i] > a[i])
      return false;
  }
  return true;
}


int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
    cin >> a[i];
  for (int i = 1; i <= m; i++)
    cin >> d[i] >> s[i] >> t[i];

  int left = 1, right = m;
  if (judge(right) == true)
  {
    cout << 0 << endl;
    return 0;
  }
  while (left < right)
  {
    int mid = left + right >> 1;
    if (judge(mid) == false)
      right = mid;
    else
      left = mid + 1;
  }
  cout << -1 << endl;
  cout << left << endl;
  return 0;
}
```
